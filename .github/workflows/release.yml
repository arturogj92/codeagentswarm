name: Build and Release

permissions:
  contents: write
  packages: write

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Type of version bump'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'

env:
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}

jobs:
  calculate-version:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      new_tag: ${{ steps.version.outputs.new_tag }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Get latest tag and calculate new version
        id: version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          
          # Remove 'v' prefix
          CURRENT_VERSION="${LATEST_TAG#v}"
          
          # Split version into components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Increment based on type
          case "${{ inputs.version_type }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          # Create new version
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="v$NEW_VERSION"
          
          echo "New version: $NEW_VERSION"
          echo "New tag: $NEW_TAG"
          
          # Check if the new tag already exists without a release
          if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
            echo "Warning: Tag $NEW_TAG already exists. Checking for associated release..."
            # Check if there's a GitHub release for this tag
            RELEASE_EXISTS=$(gh release view "$NEW_TAG" >/dev/null 2>&1 && echo "true" || echo "false")
            if [ "$RELEASE_EXISTS" = "false" ]; then
              echo "No release found for $NEW_TAG. This might be from a failed previous run."
              echo "Deleting orphaned tag $NEW_TAG..."
              git push origin --delete "$NEW_TAG" || true
              git tag -d "$NEW_TAG" || true
            else
              echo "Release already exists for $NEW_TAG. Cannot proceed."
              exit 1
            fi
          fi
          
          # Output for other jobs
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-and-release:
    needs: calculate-version
    strategy:
      matrix:
        include:
          - os: macos-latest
            platform: darwin
            arch: x64
            node_arch: x64
            build_flags: --x64
          - os: macos-latest
            platform: darwin
            arch: arm64
            node_arch: arm64
            build_flags: --arm64

    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install setuptools for node-gyp
        run: |
          python -m pip install setuptools
      
      - name: Install dependencies
        run: npm ci
      
      - name: Update package.json version
        run: |
          npm version ${{ needs.calculate-version.outputs.new_version }} --no-git-tag-version
          echo "Updated package.json to version ${{ needs.calculate-version.outputs.new_version }}"
      
      - name: Build Electron app
        run: npm run build -- ${{ matrix.build_flags }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          npm_config_arch: ${{ matrix.node_arch }}
          TARGET_ARCH: ${{ matrix.arch }}
      
      - name: Get release file info
        id: release_info
        shell: bash
        run: |
          VERSION="${{ needs.calculate-version.outputs.new_version }}"
          
          if [ "${{ matrix.platform }}" = "darwin" ]; then
            FILE=$(find dist -name "*.dmg" -o -name "*.zip" | grep -E "(dmg|mac.*zip)" | head -1)
            EXT="${FILE##*.}"
          elif [ "${{ matrix.platform }}" = "win32" ]; then
            FILE=$(find dist -name "*.exe" | grep -v "blockmap" | head -1)
            EXT="exe"
          else
            FILE=$(find dist -name "*.AppImage" -o -name "*.deb" | head -1)
            EXT="${FILE##*.}"
          fi
          
          if [ -z "$FILE" ]; then
            echo "Error: No release file found"
            exit 1
          fi
          
          FILENAME="CodeAgentSwarm-${VERSION}-${{ matrix.platform }}-${{ matrix.arch }}.${EXT}"
          # Use shasum on macOS, sha512sum on Linux
          if command -v shasum >/dev/null 2>&1; then
            SHA512=$(shasum -a 512 "$FILE" | cut -d' ' -f1)
          else
            SHA512=$(sha512sum "$FILE" | cut -d' ' -f1)
          fi
          FILESIZE=$(stat -f%z "$FILE" 2>/dev/null || stat -c%s "$FILE")
          
          echo "file=$FILE" >> $GITHUB_OUTPUT
          echo "filename=$FILENAME" >> $GITHUB_OUTPUT
          echo "sha512=$SHA512" >> $GITHUB_OUTPUT
          echo "filesize=$FILESIZE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      
      - name: Upload release to Supabase
        shell: bash
        run: |
          # Install curl if not available (for Windows)
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            choco install curl -y || apt-get update && apt-get install -y curl || true
          fi
          
          # Upload file to Supabase Storage
          UPLOAD_PATH="releases/${{ matrix.platform }}/${{ matrix.arch }}/${{ steps.release_info.outputs.version }}/${{ steps.release_info.outputs.filename }}"
          
          echo "Uploading to Supabase Storage at path: $UPLOAD_PATH"
          echo "SUPABASE_URL: ${{ secrets.SUPABASE_URL }}"
          
          UPLOAD_RESPONSE=$(curl -X POST \
            "${{ secrets.SUPABASE_URL }}/storage/v1/object/releases/$UPLOAD_PATH" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            -H "Content-Type: application/octet-stream" \
            -H "Cache-Control: public, max-age=31536000" \
            --data-binary "@${{ steps.release_info.outputs.file }}" \
            -w "\n%{http_code}")
          
          HTTP_STATUS=$(echo "$UPLOAD_RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$UPLOAD_RESPONSE" | head -n-1)
          
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Upload failed with status $HTTP_STATUS"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi
          
          # Get public URL
          PUBLIC_URL="${{ secrets.SUPABASE_URL }}/storage/v1/object/public/releases/$UPLOAD_PATH"
          echo "File uploaded successfully. Public URL: $PUBLIC_URL"
          
          # Insert release record into database
          RELEASE_DATA=$(cat <<EOF
          {
            "version": "${{ steps.release_info.outputs.version }}",
            "platform": "${{ matrix.platform }}",
            "arch": "${{ matrix.arch }}",
            "file_name": "${{ steps.release_info.outputs.filename }}",
            "file_url": "$PUBLIC_URL",
            "file_size": ${{ steps.release_info.outputs.filesize }},
            "sha512": "${{ steps.release_info.outputs.sha512 }}",
            "release_notes": "Release ${{ steps.release_info.outputs.version }}",
            "is_prerelease": false,
            "is_active": true
          }
          EOF
          )
          
          echo "Inserting release record into database..."
          DB_RESPONSE=$(curl -X POST \
            "${{ secrets.SUPABASE_URL }}/rest/v1/releases" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_KEY }}" \
            -H "Content-Type: application/json" \
            -H "Prefer: return=representation" \
            -d "$RELEASE_DATA" \
            -w "\n%{http_code}")
          
          DB_HTTP_STATUS=$(echo "$DB_RESPONSE" | tail -n1)
          DB_RESPONSE_BODY=$(echo "$DB_RESPONSE" | head -n-1)
          
          if [ "$DB_HTTP_STATUS" -ne 201 ]; then
            echo "Database insert failed with status $DB_HTTP_STATUS"
            echo "Response: $DB_RESPONSE_BODY"
            exit 1
          fi
          
          echo "Release registered successfully in database"
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: ${{ steps.release_info.outputs.file }}
          tag_name: ${{ needs.calculate-version.outputs.new_tag }}
          name: Release ${{ needs.calculate-version.outputs.new_version }}
          body: |
            ## CodeAgentSwarm ${{ steps.release_info.outputs.version }}
            
            ### Downloads
            - Platform: ${{ matrix.platform }}
            - Architecture: ${{ matrix.arch }}
            - SHA512: `${{ steps.release_info.outputs.sha512 }}`
            
            The app will auto-update to this version.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-tag:
    needs: [calculate-version, build-and-release]
    runs-on: ubuntu-latest
    if: success()
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create and push tag
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Create tag
          git tag -a "${{ needs.calculate-version.outputs.new_tag }}" -m "Release ${{ needs.calculate-version.outputs.new_version }}"
          
          # Push tag
          git push origin "${{ needs.calculate-version.outputs.new_tag }}"

  cleanup-on-failure:
    needs: [calculate-version, build-and-release, create-tag]
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Clean up failed tag if exists
        run: |
          TAG="${{ needs.calculate-version.outputs.new_tag }}"
          
          if [ -z "$TAG" ]; then
            echo "No tag to clean up"
            exit 0
          fi
          
          echo "Checking if tag $TAG exists..."
          
          # Check if tag exists locally
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG exists locally, deleting..."
            git tag -d "$TAG" || true
          fi
          
          # Check if tag exists on remote
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG"; then
            echo "Tag $TAG exists on remote, deleting..."
            git push origin --delete "$TAG" || true
          else
            echo "Tag $TAG does not exist on remote"
          fi
          
          echo "Cleanup completed"